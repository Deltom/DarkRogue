package Battle;

import Player.Player;

public class Battle
{

    public static void main(String[] args)
    {
        Player playerOne = new Player();
        Player playerTwo = new Player();
        SameMotion sameMotion = new SameMotion();

        //sameMotion.Attack(playerOne);
        //sameMotion.selectMethodsShow(playerOne,playerTwo);
        //System.out.println(sameMotion.getMethodsByTags(playerOne, playerTwo, 1));



        //Тестовый бой
        while(playerOne.getHealth() > 0 || playerTwo.getHealth() > 0)
        {
            System.out.println("Ход первого игрока");
            sameMotion.playerSelectMotion(playerOne, playerTwo);

            System.out.println("Ход второго игрока");
            sameMotion.playerSelectMotion(playerTwo, playerOne);


            System.out.println("Итоги: \nЗдоровье первого: " + playerOne.getHealth() + "\nЗдоровье второго: " + playerTwo.getHealth());
        }




    }
}

/*Продумаем реализацию боёвки. У нас есть действия, и разный исход, в зависимости от случайности и инициативы.
Каждому действию присваются теги, которые характеризуют когда это действие можно использовать.
Так же у результатов действий будут теги, показывающие от каких тегов это действие может произойти.

Реализация движений.
Будет несколько классов движений. Низкая, одинаковая и высокая(инициатива)
В классе движений будут методы всех движений(соответсвующей иниц.)
Метод содержит в себе теги(теги нескольких видов: от вас и врага. Типа попытаться прикончить лежачего,
пока противник стоит от тебя в 10 метрах идея так себе)
Каждый класс будет содержать статические переменные результатов движений чтоб можно было сравнивать
Классы низкой и высокой взаимосвязанны(типа у одного игрока низкая, а у другого высокая), поэтому
Переменные и теги, будут чутка разница

Классы результатов движений.
Три класса: результат движения низкой, одинаковой и высокой иниц.
Результат выбирает группу подходящих результатов, из ходя из тегов действий тебя и врага
А потом из ходя из стат. переменных движений выбираются то что подходит и если в итоге, вариантов больше 1, вступает рандом
 */